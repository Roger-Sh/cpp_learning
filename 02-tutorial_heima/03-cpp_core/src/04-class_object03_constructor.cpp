#include <iostream>

using namespace std;

/*

* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。


**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次


**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

// 构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

// 调用拷贝函数
// C++中拷贝构造函数调用时机通常有三种情况
// * 使用一个已经创建完毕的对象来初始化一个新对象
// * 值传递的方式给函数参数传值
// * 以值方式返回局部对象

默认情况下，c++编译器至少给一个类添加3个函数
1．默认构造函数(无参，函数体为空)
2．默认析构函数(无参，函数体为空)
3．默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：
* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数
*/


// 构造函数与析构函数
class Person
{
public:
	//构造函数 constructor
	Person()
	{
		cout << "Person的构造函数调用" << endl;
	}
	//析构函数 destructor
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}

};


// 构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person2 {
public:
	//无参（默认）构造函数
	Person2() {
		cout << "无参构造函数!" << endl;
	}

	//有参构造函数
	Person2(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}

	//拷贝构造函数， 拷贝另一个类的内容
	// 	C++中拷贝构造函数调用时机通常有三种情况
	// * 使用一个已经创建完毕的对象来初始化一个新对象
	// * 值传递的方式给函数参数传值
	// * 以值方式返回局部对象
	Person2(const Person2& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}

	//析构函数
	~Person2() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};


// 测试构造函数
void test01()
{
	Person p;	// 调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person2 p1(10);

	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();


	//2.2 显式法
	Person2 p2 = Person2(10); 	// 有参构造函数
	Person2 p3 = Person2(p2);	// 拷贝构造函数
	Person2(10);				// Person2(10)单独写就是匿名对象  当前行结束之后，马上析构
	

	//2.3 隐式转换法
	Person2 p4 = 10; // Person p4 = Person(10); 
	Person2 p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	// Person2(p4);
}



// 调用拷贝函数
// C++中拷贝构造函数调用时机通常有三种情况
// * 使用一个已经创建完毕的对象来初始化一个新对象
// * 值传递的方式给函数参数传值
// * 以值方式返回局部对象

// 值传递的方式给函数参数传值
void doWork1(Person2 man)
{
	cout << (int *)&man << endl;
}

// 以值的方式返回局部对象
Person2 doWork2()
{
	Person2 man;
	cout << (int *)&man << endl;
	return man;
} 

// 使用拷贝函数的三种场景
void test03()
{	
	// 使用已经创建完毕的对象来初始化新的对象
	Person2 man(100);	// 调用普通构造函数
	Person2 man2(man);	// 调用拷贝构造函数
	Person2 man3 = man;	// 调用拷贝构造函数

	// Person2 man4;
	// man4 = man;			// 不是调用拷贝构造函数，而是赋值

	// 值传递的方式给函数传值
	doWork1(man);			// 拷贝构造函数给函数的参数传值
	cout << (int *)&man << endl;

	// 以值返回的方式返回局部对象
	Person2 man5 = doWork2();		// 函数返回了局部对象的地址
	cout << (int *)&man5 << endl;
}



// 构造函数调用规则
void test04()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person2 p1; 		//此时如果用户自己没有提供默认构造，会出错
	Person2 p2(10); 	//用户提供的有参
	Person2 p3(p2); 	//此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person2 p4; 		//此时如果用户自己没有提供默认构造，会出错
	Person2 p5(10); 	//此时如果用户自己没有提供有参，会出错
	Person2 p6(p5); 	//用户自己提供拷贝构造
}



//深浅拷贝是面试经典问题，也是常见的一个坑
// 浅拷贝：简单的赋值拷贝操作
// 深拷贝：在堆区重新申请空间，进行拷贝操作
// 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

class Person3 {
public:
	//无参（默认）构造函数
	Person3() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person3(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person3(const Person3& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person3() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

// 尝试深浅拷贝
void test05()
{
	Person3 p1(18, 180);
	Person3 p2(p1);
	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;
	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main()
{
    test01();
    test02();
	test03();
	test04();
	test05();


    return 0;

}